[[Solved] SQLAlchemy | Alembic 空外键问题](https://github.com/AndySuen/public-notes/issues/2)

# [Solved] SQLAlchemy/Alembic 空外键问题

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [[Solved] SQLAlchemy/Alembic 空外键问题](#solved-sqlalchemyalembic-空外键问题)
    - [0. TL;DR](#0-tldr)
    - [1. 问题描述](#1-问题描述)
        - [1.1 问题确认](#11-问题确认)
        - [1.2 检查 MySQL 表结构](#12-检查-mysql-表结构)
    - [2. Hot-Fix](#2-hot-fix)
    - [3. 查阅相关文档](#3-查阅相关文档)
    - [4. 测试验证](#4-测试验证)
    - [5. 问题解决](#5-问题解决)
    - [6. 新的问题：超长名称](#6-新的问题：超长名称)
    - [7. 自动截断过长 Identifier](#7-自动截断过长-identifier)
        - [验证一下](#验证一下)
    - [8. 深入探索](#8-深入探索)
    - [9. 收尾：修复历史数据](#9-收尾：修复历史数据)
        - [修复过程](#修复过程)
    - [10. 总结](#10-总结)

<!-- markdown-toc end -->


## 0. TL;DR

1. `database-migrate` 项目多数外键约束新建时未指定 name，导致：
    1. 降级操作会报错，
    2. 后续删除外键约束时需要去数据库查找实际使用的 name 才能删除，较为繁琐。
2. SQLAlchemy / Alembic 提供了命名规则 `naming_convention` 解决上述问题——生成我们想要的 name 并自动使用到升降级中。
3. `naming_convention` 提供了对长 name 的自动截断功能。该功能是一个“运行时”概念，migration 文件中保留的是未截断的 name。
4. 运用上述 feature 后，需要对历史版本的 name 进行一次修复。
5. 以后的版本，对外键约束/唯一约束等的定义/使用不需要再指定 name。

## 1. 问题描述

最近迭代的 code review 阶段，黄健坤提出了一个修改建议：

```python
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    ...
    op.create_foreign_key(None, 'em_addition_orders', 'em_addition_order_reviews', ['last_review_id'], ['id'])
```

> 需要手动指定外键名称，并同步替换降级对应行里的`None`，否则无法正常降级

### 1.1 问题确认

生成降级文件SQL `flask db downgrade --sql`，报错：

```sh
$ flask db downgrade --sql
...
-- Running downgrade ...

Traceback (most recent call last):
  ...
  File "migrations/versions/4e5142c77ecb_feature_em_addition_v1_5.py", line 51, in downgrade
    op.drop_constraint(None, 'em_addition_orders', type_='foreignkey')
  ...
  File "venv/lib/python3.8/site-packages/sqlalchemy/engine/default.py", line 576, in validate_identifier
    if len(ident) > self.max_identifier_length:
TypeError: object of type 'NoneType' has no len()
```

但生成升级文件SQL `flask db upgrade --sql`，却正常

```sh
...
ALTER TABLE em_addition_orders ADD FOREIGN KEY(last_review_id) REFERENCES em_addition_order_reviews (id);

UPDATE alembic_version SET version_num='15a83fdcc17b' WHERE alembic_version.version_num = 'fa4f7cf00185';
```

能升级不能降级，是不是有点不合理？

### 1.2 检查 MySQL 表结构

```sql
mysql> SHOW CREATE TABLE em_addition_orders\G;
*************************** 1. row ***************************
       Table: em_addition_orders
Create Table: CREATE TABLE `em_addition_orders` (
  -- ...
  `last_review_id` bigint(20) DEFAULT NULL COMMENT '最后审核ID',
  KEY `last_review_id` (`last_review_id`),
  CONSTRAINT `em_addition_orders_ibfk_4` FOREIGN KEY (`last_review_id`) REFERENCES `em_addition_order_reviews` (`id`),
  -- ...
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```

观察到，MySQL使用了自动生成的 `em_addition_orders_ibfk_4` 作为列 `last_review_id` 的外键约束的名字。

## 2. Hot-Fix

编辑 migration 文件，将 `None` 替换为上述 `em_addition_orders_ibfk_4`，然后生成升级文件SQL和降级文件SQL，正常。

虽然问题修复了，但以后遇到该问题还是需要手动修改 migration 文件，指定外键约束名，有些麻烦，而且有可能遇到名称重复的情况。

有没有更好的办法呢？

## 3. 查阅相关文档

1. 根据 [MySQL 官方文档](https://dev.mysql.com/doc/refman/5.7/en/alter-table.html#alter-table-foreign-key)描述，

> The FOREIGN KEY and REFERENCES clauses are supported by the InnoDB and NDB storage engines, which implement `ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (...) REFERENCES ... (...)`. 
>
> For ALTER TABLE, unlike CREATE TABLE, ADD FOREIGN KEY ignores index_name if given and uses an automatically generated foreign key name. As a workaround, include the CONSTRAINT clause to specify the foreign key name.
>
> MySQL Server and NDB Cluster both support the use of ALTER TABLE to drop foreign keys:
> 
> `ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol`;

即：增加外键时，通过 `CONSTRAINT symbol` 提供外键名，而删除外键时，通过 `FOREIGN KEY fk_symbol` 提供外键名。（这里的命名竟然不统一，奇怪……）

2. Alembic 在官方文档 [The Importance of Naming Constraints - Alembic](https://alembic.sqlalchemy.org/en/latest/naming.html) 提供了两种命名方案：

    1. 在 models 的 column 上显式地指定外键约束名，例如：

      ```python
      class User(db.Model):
          id = db.Column(db.Integer, primary_key=True)
          name = db.Column(db.String(128))
          last_post_id = db.Column(db.Integer, db.ForeignKey('post.id', name='user_ibfk_1'))
          #                                                             ^^^^^^^^^^^^^^^^^^
      ```

      但这种方法只是将修改两处改为了修改一处，并没有解决上面 [Hot-Fix](#hot-fix) 提出的问题。

    2. 通过 `SQLAlchemy` 的 `metadata` 参数注入 `naming_convention` 命名规则，如下：

      ```python
      from sqlalchemy import MetaData
      from flask import Flask
      from flask_sqlalchemy import SQLAlchemy

      convention = {
          "ix": "ix_%(column_0_label)s",
          "uq": "uq_%(table_name)s_%(column_0_name)s",
          "ck": "ck_%(table_name)s_%(column_0_name)s",
          "fk": "fk_%(table_name)s_%(column_0_name)s",
          "pk": "pk_%(table_name)s"
      }

      metadata = MetaData(naming_convention=convention)
      db = SQLAlchemy(app, metadata=metadata)
      ```

      （注：Alembic 文档提供的示例不完整，上面的例子取自 [flask-sqlalchemy 官方文档](https://flask-sqlalchemy.palletsprojects.com/en/2.x/config/#using-custom-metadata-and-naming-conventions)）

      此时，新增的外键将会自动使用上述规则生成外键约束名称，migration 文件中的 `upgrade()` 和 `downgrade()` 将会使用该名称。
    
## 4. 测试验证
    
修改示例中的 models，新增 `first_post_id`:

```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128))
    last_post_id = db.Column(db.Integer, db.ForeignKey('post.id', name='user_ibfk_1'))
    # 新增 first_post_id
    first_post_id = db.Column(db.Integer, db.ForeignKey('post.id'))
```

执行 `flask db migrate -m 'first_post_id'`，生成的 migration 文件如下：

```python
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('user', sa.Column('first_post_id', sa.Integer(), nullable=True))
    op.create_foreign_key(op.f('fk_user_first_post_id_post'), 'user', 'post', ['first_post_id'], ['id'])
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(op.f('fk_user_first_post_id_post'), 'user', type_='foreignkey')
    op.drop_column('user', 'first_post_id')
    # ### end Alembic commands ###
```

执行升级/降级操作，运行正常。

## 5. 问题解决

第二种方案所需最低版本：`Alembic 0.6.4`, `SQLAlchemy 0.9.4`。确认版本满足要求。

在 `database-migrate` 项目中引入第二种方案，生成升降级文件和SQL语句都正常。 

至此，问题解决了吗？

## 6. 新的问题：名称过长

由于 MySQL 的索引名最长限制为 64 个字符，所以上述规则生成的名字可能超过了限制。

| Identifier Type          | Maximum Length (characters)         |
| ------------------------ | ----------------------------------- |
| Database                 | 64 (NDB storage engine: 63)         |
| Table                    | 64 (NDB storage engine: 63)         |
| Column                   | 64                                  |
| Index                    | 64                                  |
| Constraint               | 64                                  |
| Stored Program           | 64                                  |
| View                     | 64                                  |
| Tablespace               | 64                                  |
| Server                   | 64                                  |
| Log File Group           | 64                                  |
| Alias                    | 256 (see exception following table) |
| Compound Statement Label | 16                                  |
| User-Defined Variable    | 64                                  |


来自：[MySQL 5.7 Reference Manual /  Identifier Length Limits](https://dev.mysql.com/doc/refman/5.7/en/identifier-length.html)

对此，最简单的办法是在 `.gitlab-ci.yml` 中添加降级操作，如果遇到升级/降级报错则需介入手工修复名称问题。

```diff
   script:
     - flask db upgrade
+    - flask db downgrade

```

然而这个办法还是需要手工干预，有没有更好办法呢？

## 7. 自动截断过长 Identifier

SQLAlchemy 在 1.3.0 新增了名为 [Truncation of Long Names](https://docs.sqlalchemy.org/en/13/core/constraints.html#truncation-of-long-names) 的功能可以自动截断过长的 Identifier。其原理是对 identifier name 做截断并拼接一段 hash。源码如下：

```python
# sqlalchemy/sql/compiler.py
def _truncate_and_render_maxlen_name(self, name, max_, _alembic_quote):
    if isinstance(name, elements._truncated_label):
        if len(name) > max_:
            name = name[0 : max_ - 8] + "_" + util.md5_hex(name)[-4:]
```

只需要把命名规则中的 `column_0_name` 替换为 `column_0_N_name` 即可。

### 验证一下

编辑示例中的 `User`, 将 `first_post_id` 改为一个 61 字符长度的名字。

```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128))
    last_post_id = db.Column(db.Integer, db.ForeignKey('post.id', name='user_ibfk_1'))
    # 61 char long
    # ˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯
    first_post_id_first_post_id_first_post_id_first_post_id_58_61 = db.Column(db.Integer, db.ForeignKey('post.id'))
```

这样根据旧的规则（不支持自动截断）生成的外键约束的名称是 `fk_user_first_post_id_first_post_id_first_post_id_first_post_id_58_61` （69 char），自动截断后应该小于 64 char。

测试一下，`flask db migrate -m 'test_truncation'`，检查生成的<a id="migration-py">迁移文件</a>中的 `fk_name`:

```python
...
    sa.ForeignKeyConstraint(
      ['first_post_id_first_post_id_first_post_id_first_post_id_58_61'], 
      ['post.id'], 
      # 69 char long 
      #          ˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯
      name=op.f('fk_user_first_post_id_first_post_id_first_post_id_first_post_id_58_61')
    ),
...
```

不对啊，没截断。难道是我使用方法不对？

## 8. 深入探索

1. 重新阅读文档、检查代码、查阅 GitHub issues、检查依赖版本。没找到原因。

2. 阅读 SQLAlchemy / Alembic / Flask-SQLAlchemy / Flask-Migrate 源码、对核心源码进行 [PDB](https://docs.python.org/3.9/library/pdb.html) 断点调试（`import pdb; pdb.set_trace()`）。执行 `flask db migrate -m 'test_truncation'` 生成迁移文件，发现上述 SQLAlchemy 的 `_truncate_and_render_maxlen_name` 函数并未执行。

    此时的我：由于 SQLAlchemy / Alembic 内部调用过程异常的……长而且复杂，上述过程尤其是单步调试花了大半天时间，有点烦躁了。然而问题没有解决，还是要继续。

3. 使用 Python 内置的 [Profile](https://docs.python.org/3.9/library/profile.html) 工具生成全部调用栈 log，
    
    ```python
    #flask_migrate/cli.py
    def migrate(directory, message, sql, head, splice, branch_label, version_path, rev_id, x_arg):
    """Autogenerate a new revision file (Alias for 'revision --autogenerate')"""
        import cProfile
        pr = cProfile.Profile()
        pr.enable()
        _migrate(directory, message, sql, head, splice, branch_label, version_path, rev_id, x_arg)
        pr.disable()
        # pr.print_stats()
        pr.dump_stats('profile.log')
    ```
    
    使用 profile log 可视化工具 [SnakeViz](https://jiffyclub.github.io/snakeviz/) 辅助分析调用过程。

    ![SnakeViz](https://i.loli.net/2021/07/23/yVnxPwlEtdrkvhI.png) 

    左下角显示调用过程多达 1767 步，怪不得我单步调试的时候感觉陷入了无底洞……

    通过分析 Profile log，对 SQLAlchemy / Alembic 的运行过程多了一些了解，然而问题的原因并没有找到。

4. AHA moment

    经过上述折腾，问题依然没有解决。要不，重新试试？

    检查代码，升级依赖，生成迁移文件，输出升级 SQL

    ```SQL
    CREATE TABLE user (
        id INTEGER NOT NULL AUTO_INCREMENT,
        name VARCHAR(128),
        last_post_id INTEGER,
        first_post_id_first_post_id_first_post_id_first_post_id_57_61 INTEGER,
        CONSTRAINT pk_user PRIMARY KEY (id),
        -- 被截断的 fk_name
        --         ˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯˯
        CONSTRAINT fk_user_first_post_id_first_post_id_first_post_id_first__8972 
            FOREIGN KEY(first_post_id_first_post_id_first_post_id_first_post_id_57_61) 
            REFERENCES post (id),
        CONSTRAINT user_ibfk_1 FOREIGN KEY(last_post_id) REFERENCES post (id)
    );
    ```

    ——输出了被截断的 `fk_name`。嗯？检查一下迁移文件，还是<a href="#migration-py">未截断的样子</a>。

    原来，SQLAlchemy 的 identifier 截断功能只有在实际与 MySQL server 通信的时候才会触发，migration 文件中还是保留了未截断的名字。

    这样的好处在于：models 和 migration 的内容始终是一致的。SQLAlchemy 在与 MySQL 通信的时候会根据命名规则，动态生成截断的 identifier。此后如果 MySQL 调整了 identifier 最大长度限制，那么实际使用的时候（写表结构），SQLAlchemy 只需要根据 migration 原始的 identifier 再动态生成一次截断结果就行了，不需要用户手动干预。

## 9. 收尾：修复历史数据

由于原来的命名规则是默认的 `None => table_name_ibfk_1`，现在变成了新的 `None => fk_table_name_column_name`，使得原来删除外键可以正常运行的语句，在新规则下会提示：

```shell
"Can't DROP 'table_name_ibfk_1'; check that column/key exists"
```

这个问题修复有两个办法：

1. 找到这些手动指定过 `fk_name` 的 DROP 操作，将删除的 `fk_name` 替换为新规则生成的 `fk_table_name_column_name`。或者
2. 找到这些手动指定过 `fk_name` 的 DROP 操作对应的建表/建外键索引操作，将新建的 `fk_name` 赋值为 DROP  所指定的名称。

因为方案2所用的 `fk_name` 是旧业务代码中的 __既定事实__，故将删除/新建操作用的 `fk_name` 统一写成它，是不会出错的。

### 修复过程

导出 upgrade SQL，分别搜索 `drop foreign key` 和 `drop key`，类似如下：

```sql
ALTER TABLE role_permissions DROP FOREIGN KEY role_permissions_ibfk_1;
-- 或
DROP INDEX uq_gift_card_batches_title ON gift_card_batches;
```

找到对应的建表/建外键索引的 Python 代码，将删除所用的 `fk_name` 赋值给新建操作的 `name=op.f('')`。

大约涉及30个文件，70多处修改。

## 10. 总结

1. 有问题，按照 Google / stackoverflow / GitHub issues / Documents / 求助他人 / 分析源码这个顺序比较高效。
2. 技术债务修复得越晚，所耗费的代价越大。早发现，早治疗。
3. 写文档比想象中要费时许多。但好的文档能节省更多人的时间。
4. 文档可能会并未包含你想知道的关键信息，或者已经过时，因此可能需要分析源码。
5. 对于大型模块/库，分析源码是件令人头秃的事情。
6. 可以借助包括但不限于：IDE, PDB, Profile, 可视化工具等辅助分析。
7. 如果折腾完问题依然没有解决，睡一觉。
8. 从头再试一次，可能会发现，问题已被悄然解决。

---

(完)
